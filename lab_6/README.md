# Лабораторна робота №6 з системного програмування  
Аналіз C++-коду за допомогою C-інтерфейсу до Clang

## Мета роботи

Ознайомитися з використанням C-інтерфейсу до компілятора Clang (libclang) для побудови та аналізу абстрактного синтаксичного дерева (AST) програм мовою C++.  
Реалізувати програму, яка для одного C++-файла визначає кількість циклів, що можуть завершуватись за інструкцією `break`.

---

## Склад проєкту

У роботі використовуються два основних файли:

1. **laba6.cpp**  
   Консольна утиліта, що:
   - використовує C-інтерфейс до Clang (заголовок `clang-c/Index.h`);
   - будує AST для переданого C++-файла;
   - обходить AST і визначає цикли, які можуть завершуватись за інструкцією `break`;
   - виводить на екран кількість таких циклів.

2. **test.cpp**  
   Тестовий файл з програмою мовою C++, у якій є декілька циклів різних типів (`for`, `while`, `do-while`, range-based `for`), у тому числі:
   - цикли, які містять `break`;
   - цикли без `break`;
   - цикли, всередині яких є `switch` із `break` (де `break` належить `switch`, а не циклу).

Файл `test.cpp` можна замінювати на будь-який інший C++-файл — утиліта працює з довільною програмою мовою C++.

---

## Опис роботи програми

Програма `laba6.cpp` виконує такі кроки:

1. Створює індекс Clang:
   - `clang_createIndex` використовується для ініціалізації інфраструктури аналізу.

2. Створює `CXTranslationUnit` для заданого C++-файла:
   - використовується `clang_parseTranslationUnit`;
   - як аргументи компіляції передається, наприклад, стандарт мови (`-std=c++17`).

3. Отримує кореневий курсор абстрактного синтаксичного дерева (AST) за допомогою:
   - `clang_getTranslationUnitCursor`.

4. Рекурсивно обходить AST, використовуючи:
   - функцію `clang_visitChildren`;
   - власну функцію обходу, якій передається контекст.

5. У ході обходу програма:
   - фільтрує всі вузли, залишаючи тільки ті, що належать **основному файлу**, який аналізується:
     - для цього використовується `clang_getCursorLocation` і `clang_Location_isFromMainFile`;
   - розпізнає такі конструкції:
     - **цикли**: `ForStmt`, `WhileStmt`, `DoStmt`, `CXXForRangeStmt`;
     - **оператор `switch`**: `SwitchStmt`;
     - **інструкція `break`**: `BreakStmt`.

6. Для організації логіки використовується структура контексту:
   - вектор `nodes` для зберігання усіх break-контекстів (циклів та `switch`);
   - стек `breakable_stack`, у якому зберігаються індекси поточних вкладених контекстів, у які можна виконати `break`.

---

## Алгоритм визначення циклів з `break`

1. Під час обходу AST:

   - При знаходженні **циклу**:
     - створюється запис типу «break-контекст» з ознакою `is_loop = true` та `has_break = false`;
     - індекс цього запису додається до стеку `breakable_stack`;
     - рекурсивно обходяться нащадки вузла (тіло циклу);
     - після завершення обходу тіла індекс вилучається зі стеку.

   - При знаходженні **`switch`**:
     - створюється запис з `is_loop = false` та `has_break = false`;
     - індекс додається до стеку `breakable_stack`;
     - рекурсивно обходяться нащадки;
     - індекс вилучається зі стеку.

   - При знаходженні **інструкції `break`**:
     - програма звертається до верхівки стеку `breakable_stack`;
     - у відповідного елемента в `nodes` встановлюється прапорець `has_break = true`.

2. Таким чином:
   - якщо `break` знаходиться безпосередньо в тілі циклу, він позначає цикл як такий, що може завершитися за `break`;
   - якщо `break` знаходиться всередині `switch`, то він належить саме `switch`, а не зовнішньому циклу.

3. Після завершення обходу AST:
   - перебираються всі елементи у `nodes`;
   - рахується кількість тих, для яких:
     - `is_loop == true` (це цикл),
     - `has_break == true` (він має хоча б одну інструкцію `break`, що завершує саме цей цикл).

4. Отримане значення виводиться як кількість циклів, що можуть завершуватись за інструкцією `break`.

---

## Формат вхідних та вихідних даних

- **Вхідні дані**:  
  Ім’я C++-файла, що аналізується, передається як параметр командного рядка.

- **Вихідні дані**:  
  Програма виводить у консоль повідомлення з кількістю циклів, які можуть завершуватись за `break`.

Приклад повідомлення:
Кількість циклів, що можуть завершуватись за інструкцією break: N

де `N` — ціле число.

---

## Запуск програми

1. Компіляція програми з використанням бібліотеки `libclang`:
   ``` bash
   g++ laba6.cpp -o laba6.exe -lclang
   ```
   
   При цьому:
   - `laba6.cpp` — файл з реалізацією аналізатора;
   - `-lclang` — підключення бібліотеки Clang.

1. Запуск програми для аналізу тестового файлу:
   ```bash
   ./laba6.exe test.cpp
   ```
   
   де:
   - `test.cpp` — файл із програмою мовою C++, у якій потрібно порахувати цикли з можливим завершенням за `break`.

2. Для аналізу іншого C++-файла достатньо вказати його ім’я:

   ./laba6.exe імʼя_файла.cpp

---

## Приклад використання

1. Є файл `test.cpp` з кількома циклами, частина з яких містить інструкцію `break`.
2. Після запуску:
   ```bash
   ./laba6.exe test.cpp
   ```
   на екран виводиться кількість тих циклів, з яких можна вийти за допомогою `break`.  
   Це і є шуканий результат відповідно до умови варіанту лабораторної роботи.
